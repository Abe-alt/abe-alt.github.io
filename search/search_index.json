{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Abe's Scripts Hey! I'm Abe and this is a modest collection of scripts I've written. Shell Scripts Python Scripts Cheat Sheets","title":"Home"},{"location":"#abes-scripts","text":"Hey! I'm Abe and this is a modest collection of scripts I've written. Shell Scripts Python Scripts Cheat Sheets","title":"Abe's Scripts"},{"location":"cheatsheets/LinuxCommandLine/","text":"SYSTEM INFORMATION uname -a # Display Linux system information uname -r # Display kernel release information cat /etc/redhat-release # Show which version of Red Hat installed lsb_release -a # Show which version of Ubuntu installed uptime # Show how long the system has been running + load hostname # Show system host name hostname -I # Display all local IP addresses of the host last reboot # Show system reboot history date # Show the current date and time cal # Show this month's calendar w # Display who is online whoami # Who you are logged in as HARDWARE INFORMATION dmesg # Display messages in kernel ring buffer cat /proc/cpuinfo # Display CPU information cat /proc/meminfo # Display memory information free -h # Display free and used memory ( -h for human readable, -m for MB, -g for GB.) lspci -tv # Display PCI devices lsusb -tv # Display USB devices dmidecode # Display DMI/SMBIOS (hardware info) from the BIOS hdparm -i /dev/sda # Show info about disk sda hdparm -tT /dev/sda # Perform a read speed test on disk sda badblocks -s /dev/sda # Test for unreadable blocks on disk sda lshw # Display information about CPU, memory, storage, and network interfaces PERFORMANCE MONITORING AND STATISTICS top # Display and manage the top processes htop # Interactive process viewer (top alternative) mpstat 1 # Display processor related statistics vmstat 1 # Display virtual memory statistics iostat 1 # Display I/O statistics tail -100 /var/log/messages # Display the last 100 syslog messages (Use /var/log/syslog for Debian based systems.) tcpdump -i eth0 # Capture and display all packets on interface eth0 tcpdump -i eth0 'port 80' # Monitor all traffic on port 80 ( HTTP ) lsof # List all open files on the system lsof -u user # List files opened by user free -h # Display free and used memory ( -h for human readable, -m for MB, -g for GB.) watch df -h # Execute df -h , showing periodic updates mpstat # Display statistics about CPU usage pidstat # Display statistics about processes running USER INFORMATION AND MANAGEMENT id # Display the user and group ids of your current user. last # Display the last users who have logged onto the system. who # Show who is logged into the system. w # Show who is logged in and what they are doing. groupadd test # Create a group named test . useradd -c John Smith -m john # Create an account named john, with a comment of John Smith and create the user's home directory. userdel john # Delete the john account. usermod -aG sales john # Add the john account to the sales group FILE AND DIRECTORY COMMANDS ls -al # List all files in a long listing (detailed) format pwd # Display the present working directory mkdir directory # Create a directory rm file # Remove (delete) file rm -r directory # Remove the directory and its contents recursively rm -f file # Force removal of file without prompting for confirmation rm -rf directory # Forcefully remove directory recursively cp file1 file2 # Copy file1 to file2 cp -r source_directory destination # Copy source_directory recursively to destination. If destination exists, copy source_directory into destination, otherwise create destination with the contents of source_directory. mv file1 file2 # Rename or move file1 to file2. If file2 is an existing directory, move file1 into directory file2 ln -s /path/to/file linkname # Create symbolic link to linkname touch file # Create an empty file or update the access and modification times of file. cat file # View the contents of file less file # Browse through a text file head file # Display the first 10 lines of file tail file # Display the last 10 lines of file tail -f file # Display the last 10 lines of file and follow the file as it grows. PROCESS MANAGEMENT ps # Display your currently running processes ps -ef # Display all the currently running processes on the system. ps -ef | grep processname # Display process information for processname top # Display and manage the top processes htop # Interactive process viewer (top alternative) kill pid # Kill process with process ID of pid killall processname # Kill all processes named processname program # Start program in the background bg # Display stopped or background jobs fg # Brings the most recent background job to foreground fg n # Brings job n to the foreground nohup processname # Runs a process even after user logs out FILE PERMISSIONS chown john /path/to/file # Change ownership of /path/to/file to john chgrp sales /path/to/file # Change group ownership of /path/to/file to group sales NETWORKING ip a # Display all network interfaces and IP address ip addr show dev eth0 # Display eth0 address and details ethtool eth0 # Query or control network driver and hardware settings ping host # Send ICMP echo request to host whois domain # Display whois information for domain dig domain # Display DNS information for domain dig -x IP_ADDRESS # Reverse lookup of IP_ADDRESS host domain # Display DNS IP address for domain hostname -i # Display the network address of the host name. hostname -I # Display all local IP addresses of the host. wget http://domain.com/file # Download http://domain.com/file netstat -nutlp # Display listening tcp and udp ports and corresponding programs ifconfig # Display information about network interfaces traceroute host # Display the path that packets take to host tcpdump # Capture and analyze network traffic ARCHIVES (TAR FILES) tar cf archive.tar directory # Create tar named archive.tar containing directory. tar xf archive.tar # Extract the contents from archive.tar. tar czf archive.tar.gz directory # Create a gzip compressed tar file name archive.tar.gz. tar xzf archive.tar.gz # Extract a gzip compressed tar file. tar cjf archive.tar.bz2 directory # Create a tar file with bzip2 compression tar xjf archive.tar.bz2 # Extract a bzip2 compressed tar file. INSTALLING PACKAGES yum search keyword # Search for a package by keyword. yum install package # Install package. yum info package # Display description and summary information about package for RHEL based systems. rpm -i package.rpm # Install package from local file named package.rpm yum remove package # Remove/uninstall package for RHEL based systems. yum update package # Update package with name package for RHEL based systems. tar zxvf sourcecode.tar.gz # Install software from source code. cd sourcecode ./configure make make install apt-get update # Update package list for Debian based systems. apt-get upgrade # Upgrade all installed packages to their newest version for Debian based systems. apt-get install package # Install package with name package for Debian based systems. apt-remove package # Remove package with name package for Debian based systems. SEARCH grep pattern file # Search for pattern in file grep -r pattern directory # Search recursively for pattern in directory locate name # Find files and directories by name find /home/john -name 'prefix*' # Find files in /home/john that start with prefix . find /home -size +100M # Find files larger than 100MB in /home whereis program # Display the location of the binary, source and manual page files of program. which program # Display the path of executable that would run if program is executed. SSH LOGINS ssh host # Connect to host as your local username. ssh user@host # Connect to host as user ssh -p port user@host # Connect to host using port ssh-keygen # Create a new SSH key pair. ssh-copy-id user@host # Copy SSH key to the remote host to enable passwordless logins for user. FILE TRANSFERS scp file.txt server:/tmp # Secure copy file.txt to the /tmp folder on server scp server:/var/www/*.html /tmp # Copy *.html files from server to the local /tmp folder. scp -r server:/var/www /tmp # Copy all files and directories recursively from server to the current system's /tmp folder. rsync -a /home /backups/ # Synchronize /home to /backups/home rsync -avz /home server:/backups/ # Synchronize files/directories between the local and remote system with compression enabled ftp host # Connect to FTP server on the remote host. DISK USAGE df -h # Show free and used space on mounted filesystems df -i # Show free and used inodes on mounted filesystems fdisk -l # Display disks partitions sizes and types du -ah # Display disk usage for all files and directories in human readable format du -sh # Display total disk usage off the current directory du -a directory # Display size of all files in directory. findmnt # List all mounted file systems with details. DIRECTORY NAVIGATION cd .. # To go up one level of the directory tree. (Change into the parent directory.) cd # Go to the $HOME directory cd /etc # Change to the /etc directory alias goto=\u2019cd /etc/\u2019 # Create goto alias for command cd /etc/ . SECURITY passwd # Change the current user's password. sudo -i # Switch to the root account with root's environment. (Login shell.) sudo -s # Execute your current shell as root. (Non-login shell.) sudo -l # List sudo privileges for the current user. visudo # Edit the sudoers configuration file. getenforce # Display the current SELinux mode. sestatus # Display SELinux details such as the current SELinux mode, the configured mode, and the loaded policy. setenforce 0 # Change the current SELinux mode to Permissive. (Does not survive a reboot.) setenforce 1 # Change the current SELinux mode to Enforcing. (Does not survive a reboot.) SELINUX=enforcing # Set the SELinux mode to enforcing on boot by using this setting in the /etc/selinux/config file. SELINUX=permissive # Set the SELinux mode to permissive on boot by using this setting in the /etc/selinux/config file. SELINUX=disabled # Set the SELinux mode to disabled on boot by using this setting in the /etc/selinux/config file. LOGGING AND AUDITING dmesg # Display messages in kernel ring buffer. journalctl # Display logs stored in the systemd journal. journalctl -u servicename # Display logs for a specific unit (service).","title":"Linux Command Line"},{"location":"cheatsheets/LinuxCommandLine/#system-information","text":"uname -a # Display Linux system information uname -r # Display kernel release information cat /etc/redhat-release # Show which version of Red Hat installed lsb_release -a # Show which version of Ubuntu installed uptime # Show how long the system has been running + load hostname # Show system host name hostname -I # Display all local IP addresses of the host last reboot # Show system reboot history date # Show the current date and time cal # Show this month's calendar w # Display who is online whoami # Who you are logged in as","title":"SYSTEM INFORMATION"},{"location":"cheatsheets/LinuxCommandLine/#hardware-information","text":"dmesg # Display messages in kernel ring buffer cat /proc/cpuinfo # Display CPU information cat /proc/meminfo # Display memory information free -h # Display free and used memory ( -h for human readable, -m for MB, -g for GB.) lspci -tv # Display PCI devices lsusb -tv # Display USB devices dmidecode # Display DMI/SMBIOS (hardware info) from the BIOS hdparm -i /dev/sda # Show info about disk sda hdparm -tT /dev/sda # Perform a read speed test on disk sda badblocks -s /dev/sda # Test for unreadable blocks on disk sda lshw # Display information about CPU, memory, storage, and network interfaces","title":"HARDWARE INFORMATION"},{"location":"cheatsheets/LinuxCommandLine/#performance-monitoring-and-statistics","text":"top # Display and manage the top processes htop # Interactive process viewer (top alternative) mpstat 1 # Display processor related statistics vmstat 1 # Display virtual memory statistics iostat 1 # Display I/O statistics tail -100 /var/log/messages # Display the last 100 syslog messages (Use /var/log/syslog for Debian based systems.) tcpdump -i eth0 # Capture and display all packets on interface eth0 tcpdump -i eth0 'port 80' # Monitor all traffic on port 80 ( HTTP ) lsof # List all open files on the system lsof -u user # List files opened by user free -h # Display free and used memory ( -h for human readable, -m for MB, -g for GB.) watch df -h # Execute df -h , showing periodic updates mpstat # Display statistics about CPU usage pidstat # Display statistics about processes running","title":"PERFORMANCE MONITORING AND STATISTICS"},{"location":"cheatsheets/LinuxCommandLine/#user-information-and-management","text":"id # Display the user and group ids of your current user. last # Display the last users who have logged onto the system. who # Show who is logged into the system. w # Show who is logged in and what they are doing. groupadd test # Create a group named test . useradd -c John Smith -m john # Create an account named john, with a comment of John Smith and create the user's home directory. userdel john # Delete the john account. usermod -aG sales john # Add the john account to the sales group","title":"USER INFORMATION AND MANAGEMENT"},{"location":"cheatsheets/LinuxCommandLine/#file-and-directory-commands","text":"ls -al # List all files in a long listing (detailed) format pwd # Display the present working directory mkdir directory # Create a directory rm file # Remove (delete) file rm -r directory # Remove the directory and its contents recursively rm -f file # Force removal of file without prompting for confirmation rm -rf directory # Forcefully remove directory recursively cp file1 file2 # Copy file1 to file2 cp -r source_directory destination # Copy source_directory recursively to destination. If destination exists, copy source_directory into destination, otherwise create destination with the contents of source_directory. mv file1 file2 # Rename or move file1 to file2. If file2 is an existing directory, move file1 into directory file2 ln -s /path/to/file linkname # Create symbolic link to linkname touch file # Create an empty file or update the access and modification times of file. cat file # View the contents of file less file # Browse through a text file head file # Display the first 10 lines of file tail file # Display the last 10 lines of file tail -f file # Display the last 10 lines of file and follow the file as it grows.","title":"FILE AND DIRECTORY COMMANDS"},{"location":"cheatsheets/LinuxCommandLine/#process-management","text":"ps # Display your currently running processes ps -ef # Display all the currently running processes on the system. ps -ef | grep processname # Display process information for processname top # Display and manage the top processes htop # Interactive process viewer (top alternative) kill pid # Kill process with process ID of pid killall processname # Kill all processes named processname program # Start program in the background bg # Display stopped or background jobs fg # Brings the most recent background job to foreground fg n # Brings job n to the foreground nohup processname # Runs a process even after user logs out","title":"PROCESS MANAGEMENT"},{"location":"cheatsheets/LinuxCommandLine/#file-permissions","text":"chown john /path/to/file # Change ownership of /path/to/file to john chgrp sales /path/to/file # Change group ownership of /path/to/file to group sales","title":"FILE PERMISSIONS"},{"location":"cheatsheets/LinuxCommandLine/#networking","text":"ip a # Display all network interfaces and IP address ip addr show dev eth0 # Display eth0 address and details ethtool eth0 # Query or control network driver and hardware settings ping host # Send ICMP echo request to host whois domain # Display whois information for domain dig domain # Display DNS information for domain dig -x IP_ADDRESS # Reverse lookup of IP_ADDRESS host domain # Display DNS IP address for domain hostname -i # Display the network address of the host name. hostname -I # Display all local IP addresses of the host. wget http://domain.com/file # Download http://domain.com/file netstat -nutlp # Display listening tcp and udp ports and corresponding programs ifconfig # Display information about network interfaces traceroute host # Display the path that packets take to host tcpdump # Capture and analyze network traffic","title":"NETWORKING"},{"location":"cheatsheets/LinuxCommandLine/#archives-tar-files","text":"tar cf archive.tar directory # Create tar named archive.tar containing directory. tar xf archive.tar # Extract the contents from archive.tar. tar czf archive.tar.gz directory # Create a gzip compressed tar file name archive.tar.gz. tar xzf archive.tar.gz # Extract a gzip compressed tar file. tar cjf archive.tar.bz2 directory # Create a tar file with bzip2 compression tar xjf archive.tar.bz2 # Extract a bzip2 compressed tar file.","title":"ARCHIVES (TAR FILES)"},{"location":"cheatsheets/LinuxCommandLine/#installing-packages","text":"yum search keyword # Search for a package by keyword. yum install package # Install package. yum info package # Display description and summary information about package for RHEL based systems. rpm -i package.rpm # Install package from local file named package.rpm yum remove package # Remove/uninstall package for RHEL based systems. yum update package # Update package with name package for RHEL based systems. tar zxvf sourcecode.tar.gz # Install software from source code. cd sourcecode ./configure make make install apt-get update # Update package list for Debian based systems. apt-get upgrade # Upgrade all installed packages to their newest version for Debian based systems. apt-get install package # Install package with name package for Debian based systems. apt-remove package # Remove package with name package for Debian based systems.","title":"INSTALLING PACKAGES"},{"location":"cheatsheets/LinuxCommandLine/#search","text":"grep pattern file # Search for pattern in file grep -r pattern directory # Search recursively for pattern in directory locate name # Find files and directories by name find /home/john -name 'prefix*' # Find files in /home/john that start with prefix . find /home -size +100M # Find files larger than 100MB in /home whereis program # Display the location of the binary, source and manual page files of program. which program # Display the path of executable that would run if program is executed.","title":"SEARCH"},{"location":"cheatsheets/LinuxCommandLine/#ssh-logins","text":"ssh host # Connect to host as your local username. ssh user@host # Connect to host as user ssh -p port user@host # Connect to host using port ssh-keygen # Create a new SSH key pair. ssh-copy-id user@host # Copy SSH key to the remote host to enable passwordless logins for user.","title":"SSH LOGINS"},{"location":"cheatsheets/LinuxCommandLine/#file-transfers","text":"scp file.txt server:/tmp # Secure copy file.txt to the /tmp folder on server scp server:/var/www/*.html /tmp # Copy *.html files from server to the local /tmp folder. scp -r server:/var/www /tmp # Copy all files and directories recursively from server to the current system's /tmp folder. rsync -a /home /backups/ # Synchronize /home to /backups/home rsync -avz /home server:/backups/ # Synchronize files/directories between the local and remote system with compression enabled ftp host # Connect to FTP server on the remote host.","title":"FILE TRANSFERS"},{"location":"cheatsheets/LinuxCommandLine/#disk-usage","text":"df -h # Show free and used space on mounted filesystems df -i # Show free and used inodes on mounted filesystems fdisk -l # Display disks partitions sizes and types du -ah # Display disk usage for all files and directories in human readable format du -sh # Display total disk usage off the current directory du -a directory # Display size of all files in directory. findmnt # List all mounted file systems with details.","title":"DISK USAGE"},{"location":"cheatsheets/LinuxCommandLine/#directory-navigation","text":"cd .. # To go up one level of the directory tree. (Change into the parent directory.) cd # Go to the $HOME directory cd /etc # Change to the /etc directory alias goto=\u2019cd /etc/\u2019 # Create goto alias for command cd /etc/ .","title":"DIRECTORY NAVIGATION"},{"location":"cheatsheets/LinuxCommandLine/#security","text":"passwd # Change the current user's password. sudo -i # Switch to the root account with root's environment. (Login shell.) sudo -s # Execute your current shell as root. (Non-login shell.) sudo -l # List sudo privileges for the current user. visudo # Edit the sudoers configuration file. getenforce # Display the current SELinux mode. sestatus # Display SELinux details such as the current SELinux mode, the configured mode, and the loaded policy. setenforce 0 # Change the current SELinux mode to Permissive. (Does not survive a reboot.) setenforce 1 # Change the current SELinux mode to Enforcing. (Does not survive a reboot.) SELINUX=enforcing # Set the SELinux mode to enforcing on boot by using this setting in the /etc/selinux/config file. SELINUX=permissive # Set the SELinux mode to permissive on boot by using this setting in the /etc/selinux/config file. SELINUX=disabled # Set the SELinux mode to disabled on boot by using this setting in the /etc/selinux/config file.","title":"SECURITY"},{"location":"cheatsheets/LinuxCommandLine/#logging-and-auditing","text":"dmesg # Display messages in kernel ring buffer. journalctl # Display logs stored in the systemd journal. journalctl -u servicename # Display logs for a specific unit (service).","title":"LOGGING AND AUDITING"},{"location":"cheatsheets/PythonVenvCommands/","text":"Creating virtual environment Creation of virtual environments is done by executing the command venv: python3 -m venv /path/to/new/virtual/environment Activate a virtual environment $ source venv /bin/activate Install the requirements file Use pip to install all of the packages needed by the environment. pip install -r requirements.txt Deactivate a virtual environment deactivate Show installed packages in requirements format pip freeze Generate the requirements file pip freeze requirements.txt","title":"Python Virtual Environment Commands"},{"location":"cheatsheets/PythonVenvCommands/#creating-virtual-environment","text":"Creation of virtual environments is done by executing the command venv: python3 -m venv /path/to/new/virtual/environment","title":"Creating virtual environment"},{"location":"cheatsheets/PythonVenvCommands/#activate-a-virtual-environment","text":"$ source venv /bin/activate","title":"Activate a virtual environment"},{"location":"cheatsheets/PythonVenvCommands/#install-the-requirements-file","text":"Use pip to install all of the packages needed by the environment. pip install -r requirements.txt","title":"Install the requirements file"},{"location":"cheatsheets/PythonVenvCommands/#deactivate-a-virtual-environment","text":"deactivate","title":"Deactivate a virtual environment"},{"location":"cheatsheets/PythonVenvCommands/#show-installed-packages-in-requirements-format","text":"pip freeze","title":"Show installed packages in requirements format"},{"location":"cheatsheets/PythonVenvCommands/#generate-the-requirements-file","text":"pip freeze requirements.txt","title":"Generate the requirements file"},{"location":"python/Connect_to_a_Cisco_device_with_Netmiko/","text":"Connect to a Cisco device with Netmiko This Python script uses the Netmiko module to establish SSH connections to a Cisco IOS device and execute CLI commands on that device. from netmiko import Netmiko cisco_sandbox_devices = { ios : { hostname : sandbox-iosxe-latest-1.cisco.com , port : 22, username : developer , password : C1sco12345 , device_type : cisco_ios , }, } def netmiko_connect(device_type): print( f \\n\\nConnecting to {cisco_sandbox_devices[device_type]['hostname']}:{cisco_sandbox_devices[device_type]['port']} ) print( ... this may take a little while. ) connection = Netmiko( cisco_sandbox_devices[device_type][ hostname ], port=cisco_sandbox_devices[device_type][ port ], username=cisco_sandbox_devices[device_type][ username ], password=cisco_sandbox_devices[device_type][ password ], device_type=cisco_sandbox_devices[device_type][ device_type ], ) return connection def disconnect(connection): connection.disconnect() SHOW_IP_ROUTE = ip route SHOW_ARP = arp SHOW_INT_DESCRIPTION = int description SHOW_INT_BRIEF = int brief SHOW_VERSION = version IOS = ios commands = {SHOW_IP_ROUTE: {IOS: show ip route }, SHOW_ARP: {IOS: show arp }, SHOW_INT_DESCRIPTION: {IOS: show interfaces description }, SHOW_INT_BRIEF: {IOS: show ip interface brief }, SHOW_VERSION: {IOS: show version } } # CYCLE THROUGH DIFFERENT DEVICE TYPES for device_type in [IOS]: connection = netmiko_connect(device_type) print('connection:', connection) print(f \\n\\n----- showing running configuration for {device_type} ------------------- ) output = connection.send_command( show running-config ) print(output) print(f \\n\\n----- showing ip route for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_IP_ROUTE][device_type]) print(output) print(f \\n\\n----- showing arp table for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_ARP][device_type]) print(output) print(f \\n\\n----- showing interface description for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_INT_DESCRIPTION][device_type]) print(output) print(f \\n\\n----- showing interface brief for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_INT_BRIEF][device_type]) print(output) connection.disconnect() The netmiko_connect() function takes a device_type argument, uses the connection details from the cisco_sandbox_devices dictionary to establish an SSH connection to the device using Netmiko , and returns the connection object. The disconnect() function takes a connection argument and uses the disconnect() method from Netmiko to close the SSH connection. Several constants are defined that represent Cisco IOS CLI commands, and a dictionary called commands maps these commands to their equivalent Cisco IOS CLI commands. The script then iterates over the commands dictionary, establishing a connection to the Cisco IOS device using netmiko_connect() , and using the send_command() method of the connection object to send each command and print the resulting output to the console. Finally, the connection is closed using the disconnect() function.","title":"Connect to a Cisco device with Netmiko"},{"location":"python/Connect_to_a_Cisco_device_with_Netmiko/#connect-to-a-cisco-device-with-netmiko","text":"This Python script uses the Netmiko module to establish SSH connections to a Cisco IOS device and execute CLI commands on that device. from netmiko import Netmiko cisco_sandbox_devices = { ios : { hostname : sandbox-iosxe-latest-1.cisco.com , port : 22, username : developer , password : C1sco12345 , device_type : cisco_ios , }, } def netmiko_connect(device_type): print( f \\n\\nConnecting to {cisco_sandbox_devices[device_type]['hostname']}:{cisco_sandbox_devices[device_type]['port']} ) print( ... this may take a little while. ) connection = Netmiko( cisco_sandbox_devices[device_type][ hostname ], port=cisco_sandbox_devices[device_type][ port ], username=cisco_sandbox_devices[device_type][ username ], password=cisco_sandbox_devices[device_type][ password ], device_type=cisco_sandbox_devices[device_type][ device_type ], ) return connection def disconnect(connection): connection.disconnect() SHOW_IP_ROUTE = ip route SHOW_ARP = arp SHOW_INT_DESCRIPTION = int description SHOW_INT_BRIEF = int brief SHOW_VERSION = version IOS = ios commands = {SHOW_IP_ROUTE: {IOS: show ip route }, SHOW_ARP: {IOS: show arp }, SHOW_INT_DESCRIPTION: {IOS: show interfaces description }, SHOW_INT_BRIEF: {IOS: show ip interface brief }, SHOW_VERSION: {IOS: show version } } # CYCLE THROUGH DIFFERENT DEVICE TYPES for device_type in [IOS]: connection = netmiko_connect(device_type) print('connection:', connection) print(f \\n\\n----- showing running configuration for {device_type} ------------------- ) output = connection.send_command( show running-config ) print(output) print(f \\n\\n----- showing ip route for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_IP_ROUTE][device_type]) print(output) print(f \\n\\n----- showing arp table for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_ARP][device_type]) print(output) print(f \\n\\n----- showing interface description for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_INT_DESCRIPTION][device_type]) print(output) print(f \\n\\n----- showing interface brief for {device_type} ------------------- ) output = connection.send_command(commands[SHOW_INT_BRIEF][device_type]) print(output) connection.disconnect() The netmiko_connect() function takes a device_type argument, uses the connection details from the cisco_sandbox_devices dictionary to establish an SSH connection to the device using Netmiko , and returns the connection object. The disconnect() function takes a connection argument and uses the disconnect() method from Netmiko to close the SSH connection. Several constants are defined that represent Cisco IOS CLI commands, and a dictionary called commands maps these commands to their equivalent Cisco IOS CLI commands. The script then iterates over the commands dictionary, establishing a connection to the Cisco IOS device using netmiko_connect() , and using the send_command() method of the connection object to send each command and print the resulting output to the console. Finally, the connection is closed using the disconnect() function.","title":"Connect to a Cisco device with Netmiko"},{"location":"python/Connect_to_a_device_with_Napalm/","text":"Connect to a device with Napalm NAPALM (Network Automation and Programmability Abstraction Layer with Multivendor support) is a Python library that implements a set of functions to interact with different network device Operating Systems using a unified API. Useful library to coonect to devices without worrying about their type. import napalm import json import copy from connect import cisco_sandbox_devices IOS = ios NXOS = nxos NXOS_SSH = nxos_ssh devices = copy.deepcopy(cisco_sandbox_devices) for device_type, device in devices.items(): print(f \\n----- connecting to device {device_type}: {device['hostname']} ---------- ) driver = napalm.get_network_driver(device_type) if device_type == IOS: napalm_device = driver( hostname=device[ hostname ], username=device[ username ], password=device[ password ], ) else: napalm_device = driver( hostname=device[ hostname ], username=device[ username ], password=device[ password ], optional_args={ port : device[ port ]}, ) napalm_device.open() print( \\n----- facts ---------- ) print(json.dumps(napalm_device.get_facts(), sort_keys=True, indent=4)) print( \\n----- interfaces ---------- ) print(json.dumps(napalm_device.get_interfaces(), sort_keys=True, indent=4)) print( \\n----- vlans ---------- ) try: print(json.dumps(napalm_device.get_vlans(), sort_keys=True, indent=4)) except NotImplementedError as e: print(f oops, looks like this isn't implemented for {device['hostname']}, error: {e} ) print( \\n----- snmp ---------- ) print(json.dumps(napalm_device.get_snmp_information(), sort_keys=True, indent=4)) print( \\n----- interface counters ---------- ) try: print(json.dumps(napalm_device.get_interfaces_counters(), sort_keys=True, indent=4)) except NotImplementedError as e: print(f oops, looks like this isn't implemented for {device['hostname']}, error: {e} ) print( \\n----- environment ---------- ) try: print(json.dumps(napalm_device.get_environment(), sort_keys=True, indent=4)) except (KeyError, IOError, napalm.pyIOSXR.exceptions.XMLCLIError) as e: print(f oops, looks like there is a NAPALM exception for {device['hostname']}, error: {e} ) napalm_device.close()","title":"Connect to a device with Napalm"},{"location":"python/Connect_to_a_device_with_Napalm/#connect-to-a-device-with-napalm","text":"NAPALM (Network Automation and Programmability Abstraction Layer with Multivendor support) is a Python library that implements a set of functions to interact with different network device Operating Systems using a unified API. Useful library to coonect to devices without worrying about their type. import napalm import json import copy from connect import cisco_sandbox_devices IOS = ios NXOS = nxos NXOS_SSH = nxos_ssh devices = copy.deepcopy(cisco_sandbox_devices) for device_type, device in devices.items(): print(f \\n----- connecting to device {device_type}: {device['hostname']} ---------- ) driver = napalm.get_network_driver(device_type) if device_type == IOS: napalm_device = driver( hostname=device[ hostname ], username=device[ username ], password=device[ password ], ) else: napalm_device = driver( hostname=device[ hostname ], username=device[ username ], password=device[ password ], optional_args={ port : device[ port ]}, ) napalm_device.open() print( \\n----- facts ---------- ) print(json.dumps(napalm_device.get_facts(), sort_keys=True, indent=4)) print( \\n----- interfaces ---------- ) print(json.dumps(napalm_device.get_interfaces(), sort_keys=True, indent=4)) print( \\n----- vlans ---------- ) try: print(json.dumps(napalm_device.get_vlans(), sort_keys=True, indent=4)) except NotImplementedError as e: print(f oops, looks like this isn't implemented for {device['hostname']}, error: {e} ) print( \\n----- snmp ---------- ) print(json.dumps(napalm_device.get_snmp_information(), sort_keys=True, indent=4)) print( \\n----- interface counters ---------- ) try: print(json.dumps(napalm_device.get_interfaces_counters(), sort_keys=True, indent=4)) except NotImplementedError as e: print(f oops, looks like this isn't implemented for {device['hostname']}, error: {e} ) print( \\n----- environment ---------- ) try: print(json.dumps(napalm_device.get_environment(), sort_keys=True, indent=4)) except (KeyError, IOError, napalm.pyIOSXR.exceptions.XMLCLIError) as e: print(f oops, looks like there is a NAPALM exception for {device['hostname']}, error: {e} ) napalm_device.close()","title":"Connect to a device with Napalm"},{"location":"shell/create_user_account/","text":"Create a user account This Bash script creates a user account if no arguments are passed, or deletes a user account if \"del\" and the username are passed as arguments. #! /usr/bin/bash if [ -z ${1} ] then echo What is your intended username? read username echo What is your password read password #A user can be passed in as a command line argument echo $username user account being created. #A user is created with the name of command line argument sudo useradd -m $username #A password can be parsed in as a command line argument. sudo chpasswd $username:$password sleep 2 echo If you want to delete the user then pass 'del' and username in command line argument. e.g: ./create-user.sh del username else sudo userdel -rf ${2} sleep 2 echo ${2} user account successfully deleted. exit 0 fi In this specific case, the condition checks whether the length of the first command line argument (represented by the $1 variable) is zero or not. If it is zero, then the script assumes that no arguments were passed, and proceeds to prompt the user to input a username and password to create a new user account. Otherwise, it assumes that the first argument is \"del\", and proceeds to delete the user account specified by the second argument.","title":"Create a user account"},{"location":"shell/create_user_account/#create-a-user-account","text":"This Bash script creates a user account if no arguments are passed, or deletes a user account if \"del\" and the username are passed as arguments. #! /usr/bin/bash if [ -z ${1} ] then echo What is your intended username? read username echo What is your password read password #A user can be passed in as a command line argument echo $username user account being created. #A user is created with the name of command line argument sudo useradd -m $username #A password can be parsed in as a command line argument. sudo chpasswd $username:$password sleep 2 echo If you want to delete the user then pass 'del' and username in command line argument. e.g: ./create-user.sh del username else sudo userdel -rf ${2} sleep 2 echo ${2} user account successfully deleted. exit 0 fi In this specific case, the condition checks whether the length of the first command line argument (represented by the $1 variable) is zero or not. If it is zero, then the script assumes that no arguments were passed, and proceeds to prompt the user to input a username and password to create a new user account. Otherwise, it assumes that the first argument is \"del\", and proceeds to delete the user account specified by the second argument.","title":"Create a user account"},{"location":"shell/ex2/","text":"","title":"ex2"}]}